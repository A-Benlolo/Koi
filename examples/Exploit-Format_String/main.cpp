#include <iomanip>
#include <Koi/bait.h>
#include <Koi/swimmer.h>
#include <Koi/bait.h>


/** Skip functions that are of no interest and with no side-effects */
triton::uint64 skip(Swimmer *s, triton::uint64 addr) { return 0; }

/** On printf, the format string should be concrete */
triton::uint64 check_printf(Swimmer *s, triton::uint64 addr) {
    // The first variable is pushed on the stack using eax
    auto eax = s->registers.x86_eax;
    triton::uint64 ptr = triton::uint64(s->getConcreteRegisterValue(eax));
    
    // Verify concrete format string
    if(s->isMemorySymbolized(ptr)) {
        std::cout << "\033[1m\033[33mWARNING\033[0m\033[33m" << std::endl
                  << "Format string vulnerability @ 0x" << std::hex << addr << "..." << std::endl
                  << "The format string is symbolic" << std::endl
                  << "This allows arbitrary read/writes in memory" << std::endl
                  << "\033[0m" << std::dec << std::endl;
    }
    else
        std::cout << "\033[1mFormat string is concrete\033[0m" << std::endl << std::endl;

    return 0;
}


int main(int argc, char *argv[]) {
    // Print a banner
    std::cout << ".-----------------------------." << std::endl;
    std::cout << "| Format String Vulnerability |" << std::endl;
    std::cout << "'-----------------------------'" << std::endl;

    // Create the symbolic swimmer
    Swimmer swimmer = Swimmer("./66feb83e9b533b4c22bd0c13");
    swimmer.setPc(0x814927f);
    swimmer.verbosity = Swimmer::SV_CTRLFLOW;

    // Assume a program parameter was given
    swimmer.setConcreteMemoryValue(0x80000002, 2);

    // Hook library functions
    swimmer.hookFunction(0x8149070, koi_strncpy);
    swimmer.hookFunction(0x8149040, check_printf);
    swimmer.hookFunction(0x81490d0, skip);
    swimmer.hookFunction(0x8149060, skip);

    // Explore to the address where the format vulnerability occurs
    const uint TARGET_ADDRESS = 0x8149247;
    bool success = swimmer.explore(TARGET_ADDRESS);
    
    return 0;
}
